The k-sum problem
=========
The k-sum problem is very classic. Basically it is described as follows:  
Given an integer array `nums`, an integer `k` and a target number `target`, find out all `k`-sized subsets of  `nums` such that `sum(subset[::]) == target`.  
  
There may be other constrains, such as:  
```
1. The original array may have duplicated elements, but your output should not contains duplicated subsets;
2. Each of your output subset should have ascending order inside;
```

## Problem Analysis  

### 1. How to solve 2-sum?
It is useful to reduce the problem to the simplest case at first. We reduce k to 2, and assume that every elements in the array are different, and the elements of a subset can be in any order.  
  
2-sum can be easily solved by brute force method. Using two `for` loops, we can enumerate each and every subsets of size 2 in `nums`.  
```python
def fourSum(array, target):
    n = len(array)
    ret = []
    for i in range(n):
        for j in range(i+1, n):
            if array[i] + array[j] == target:
                ret.append([array[i], array[j]])
    return ret
```
Obviously this method has $O(n^2)$ time complexity. In general, it has $O(n^k)$ complexity for k-sum problems.  
  
Certainly there is space for improvement. To find a subset `{a,b}` that can add up to `target`, we can iterate through all elements `a` of `nums` and find if there is another element `b` such that `target - a == b`. There are two ways:  
#### A. Hash map
First, we insert elements of `nums` into a hash map `Hmap`. Then for each `a`, we find `target - a` in `Hmap`. Since `find()` operation of a hash map only takes $O(1)$ time, this method (theoretically) takes only $O(n)$ time.  
```python
def twoSum(array, target):
    n = len(array)
    ret = []
    Hmap = dict()
    for i in range(n):
        Hmap[array[i]] = array[i]
    for i in range(n):
    # be careful about duplication
        if target - array[i] in Hmap and [array[i], target - array[i]] not in ret and [target - array[i],array[i]] not in ret:
            ret.append([array[i],target - array[i]])
    return ret
```

#### B. sort, and then find
Method A has a space complexity trade-off, which may be undesirable in some situations. As the book *Algorithm* shows, using sorting and binary search can solve the problem without extra space cost:  
```C++
vector<vector<int>> twoSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    int n = nums.size();
    if(n < 2) return res;
    sort(nums.begin(),nums.end());
    for(int i = 0; i < n; i++){
        int index = BinarySearch(target-nums[i], nums);
        if(index > i) {     // to avoid duplication
            res.push_back(vector<int>(nums[i], target-nums[i]));
        }
    }
    return res; 
}
```
Here, `BinarySearch(tar, array)` do a binary search and returns the index of `tar` in a sorted array.  
  
In addition to binary search, we can also use two pointers after sorting the original array:  
```C++
vector<vector<int>> twoSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    int n = nums.size();
    if(n < 2) return res;
    sort(nums.begin(),nums.end());
    int i = 0, j = n-1;
    while(i < j){
        if(nums[i] + nums[j] < target) i++;
        else if (nums[i] + nums[j] > target) j--;
        else {
            res.push_back(vector<int>(nums[i],nums[j]));
            i++;j--;
        }
    }
    return res; 
}
```
We first mantain two pointers at head and tail of the array. Since the array is sorted, when `nums[i] + nums[j] < target`, we know that `nums[i]` is too small, and we should let `i++` to check the next element. Similarly, when `nums[i] + nums[j] > target`, we do `j--` because `nums[j]` is too large. When we find a pair (`nums[i] + nums[j] == target`), we add the pair to the result and simutaneously increase(or decrease) the two pointers to check the next state.  
  
Because both of the two methods in B needs sorting, so the time complexity is at least $O(nlogn)$. However, in "find" process, the second method is better since it takes $O(n)$ while finding with`BinarySearch()` takes $O(nlogn)$ in total.  

### 2. How about 3-sum, 4-sum and so on?
Once we know how to solve 2-sum, it is easy to solve 3-sum "recursively". Here the real program need not to be recursive, but we can **split 3-sum into 2-sum**.  
  
We know that `subset_size_3(nums) = {nums[0]}∪subset_size_two(nums[1::]) + {nums[1]}∪subset_size_two(nums[2::]) + ... + {nums[n-3]}∪subset_size_two(nums[n-2::])`. In this case, we need an outer `for` loop to get the first element of one subset, and 
the second and third elements will be generated by `twoSum()`.
  
Similarly, 4-sum and any k-sum problems can be solved with this method. If we use "sorting + two pointers" to solve 2-sum problem, then given a sorted array, its time complexity can reach $O(n)$. Therefore, **time complexity for k-sum problem (k >= 3) can reach $O(n^{k-1})$.**

## How To (In C++)
If we know that k=4 in advance, we can managed to do some optimization so that the actual running time will not reach the worst case:  
```C++
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> total;
        int n = nums.size();
        if(n<4)  return total;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n-3;i++)
        {
            if(i>0 && nums[i]==nums[i-1]) continue;   // avoid duplicated elements
            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;   // eliminate if the smallest sum is larger than the target
            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;    // skip if i is too small
            for(int j=i+1;j<n-2;j++)
            {
                if(j>i+1 && nums[j]==nums[j-1]) continue; // avoid duplicated elements
                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;   // eliminate if the smallest sum is larger than the target
                if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;   // skip if j is too small
                int left=j+1,right=n-1;
                // two-sum process
                while(left<right){
                    int sum=nums[left]+nums[right]+nums[i]+nums[j];
                    if(sum<target) left++;
                    else if(sum>target) right--;
                    else{
                        total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        do{left++;}while(nums[left]==nums[left-1] && left<right);   // avoid duplicated elements
                        do{right--;}while(nums[right]==nums[right+1] && left<right);   // avoid duplicated elements
                    }
                }
            }
        }
        return total;
    }
```
Here we skip some situations that are impossible to generate a subset. For example, if the smallest sum (sum from `nums[i]` to `nums[i+3]`) is larger than the target, or `nums[i]` adds sum of the 3 largest elements is smaller than the target. By skipping and "prunning", the actual running time will be far better than the worst estimation.  
  
If we have no idea about `k` in advance, we can use recursive function to solve:  
```C++
void findNSum(vector<int>& nums, int l, int r, int target, int N, vector<int> temp, vector<vector<int>>& res) {
    if (r - l + 1 < N || N < 2 || target < nums[l] * N || target > nums[r] * N)  return;
    if (N == 2) {
    // two pointers solve sorted 2-sum problem
    while (l < r) {
        int s = nums[l] + nums[r];
        if (s == target) {
            vector<int> t;
            t.insert(t.end(), temp.begin(), temp.end());
            t.push_back(nums[l]);
            t.push_back(nums[r]);
            res.push_back(t);
            l += 1;
            while (l < r && nums[l] == nums[l - 1]) l += 1;
        }
        else if (s < target)
            l += 1;
        else
            r -= 1;
      }
    }
    else {
      // recursively reduce N
        for (int i = l; i <= r; i++) {
            if (i == l || (i > l && nums[i - 1] != nums[i])) {
                vector<int> t;
                t.insert(t.end(), temp.begin(), temp.end());
                t.push_back(nums[i]);
                findNSum(nums, i + 1, r, target - nums[i], N - 1, t, res);
        }
      }
    }
  }
    
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> total;
    int n = nums.size();
    if(n<4)  return total;
    sort(nums.begin(),nums.end());
    vector<int> temp;
    findNSum(nums, 0, n-1, target, 4, temp, total);
    return total;
}
```
Although this function still need some optimization for some details, it's using quite the same principal. It also sift some impossible cases at the beginning. The two methods actually have very close performance on leetcode.

